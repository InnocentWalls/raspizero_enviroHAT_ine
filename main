#!/usr/bin/env python3

import time
import json
import requests
import logging
from datetime import datetime, timezone, timedelta
import sys
import os
import socket
import schedule
import backoff

# Import Enviro+ libraries
from bme280 import BME280
from ltr559 import LTR559

try:
    from smbus2 import SMBus
except ImportError:
    from smbus import SMBus

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("enviroplus_sender.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("enviroplus_sender")

# Constants and configuration
ENDPOINT_URL = "https://your-custom-endpoint-url.com/data"  # Replace with your actual endpoint
DEVICE_UID = "e6614c775b8c4035"
DEVICE_NICKNAME = "weather-test"
DEVICE_MODEL = "grow"
MAX_RETRIES = 5
RETRY_DELAY = 60  # seconds between retries
DATA_BACKUP_PATH = "backup_data"

# Set up the sensors
bus = SMBus(1)
bme280 = BME280(i2c_dev=bus)
ltr559 = LTR559()

# Create backup directory if it doesn't exist
if not os.path.exists(DATA_BACKUP_PATH):
    os.makedirs(DATA_BACKUP_PATH)

# Function to read sensor data
def read_sensors():
    try:
        # Read temperature, pressure, and humidity from BME280
        temperature = bme280.get_temperature()
        pressure = bme280.get_pressure()
        humidity = bme280.get_humidity()
        
        # Read light from LTR559
        light = ltr559.get_lux()
        
        return {
            "temperature": round(temperature, 2),
            "humidity": round(humidity, 2),
            "pressure": round(pressure, 2),
            "light": round(light, 2)
        }
    except Exception as e:
        logger.error(f"Error reading sensors: {e}")
        # Return previous values if available or default values
        return {
            "temperature": 0.0,
            "humidity": 0.0,
            "pressure": 0.0,
            "light": 0.0
        }

# Check internet connection
def is_connected():
    try:
        # Try to resolve a common reliable domain
        socket.create_connection(("1.1.1.1", 53), timeout=3)
        return True
    except OSError:
        pass
    return False

# Backup data to a file
def backup_data(payload):
    timestamp = payload["timestamp"].replace(":", "-")
    filename = os.path.join(DATA_BACKUP_PATH, f"data_{timestamp}.json")
    try:
        with open(filename, "w") as f:
            json.dump(payload, f)
        logger.info(f"Data backed up to {filename}")
        return filename
    except Exception as e:
        logger.error(f"Failed to backup data: {e}")
        return None

# Try to send backed up data
def send_backed_up_data():
    if not is_connected():
        logger.warning("No internet connection. Skipping backed up data sending.")
        return

    files = os.listdir(DATA_BACKUP_PATH)
    if not files:
        return
    
    logger.info(f"Found {len(files)} backed up data files to send")
    
    for filename in files:
        filepath = os.path.join(DATA_BACKUP_PATH, filename)
        try:
            with open(filepath, "r") as f:
                payload = json.load(f)
                
            # Try to send the data
            success = send_data_with_retry(payload)
            
            # If successfully sent, remove the backup file
            if success:
                os.remove(filepath)
                logger.info(f"Backed up data {filename} sent and file removed")
        except Exception as e:
            logger.error(f"Error processing backed up file {filename}: {e}")

# Function to create and send the payload with exponential backoff
@backoff.on_exception(
    backoff.expo,
    (requests.exceptions.RequestException, socket.error),
    max_tries=MAX_RETRIES
)
def send_with_backoff(payload):
    headers = {"Content-Type": "application/json"}
    response = requests.post(
        ENDPOINT_URL, 
        data=json.dumps(payload), 
        headers=headers,
        timeout=10  # Set a timeout for the request
    )
    response.raise_for_status()  # Raise an exception for 4XX/5XX responses
    return response

# Send data with retry logic
def send_data_with_retry(payload):
    try:
        if not is_connected():
            logger.warning("No internet connection. Backing up data.")
            backup_data(payload)
            return False
            
        response = send_with_backoff(payload)
        logger.info(f"Data sent successfully at {payload['timestamp']}")
        logger.debug(f"Payload: {json.dumps(payload, indent=2)}")
        return True
        
    except requests.exceptions.HTTPError as e:
        logger.error(f"HTTP error: {e}")
        backup_data(payload)
        return False
    except (requests.exceptions.ConnectionError, socket.error) as e:
        logger.error(f"Connection error: {e}")
        backup_data(payload)
        return False
    except Exception as e:
        logger.error(f"Error sending data: {e}")
        backup_data(payload)
        return False

# Function to create and send the payload
def process_and_send_data():
    logger.info("Running scheduled data collection and sending")
    
    # Get current time in Japan timezone (UTC+9)
    japan_timezone = timezone(timedelta(hours=9))
    current_time = datetime.now(japan_timezone).strftime("%Y-%m-%dT%H:%M:%SZ")
    
    # Read sensor data
    sensor_data = read_sensors()
    
    # Create payload
    payload = {
        "nickname": DEVICE_NICKNAME,
        "model": DEVICE_MODEL,
        "uid": DEVICE_UID,
        "timestamp": current_time,
        "readings": sensor_data
    }
    
    # Try to send data
    send_data_with_retry(payload)
    
    # Try to send any backed up data
    send_backed_up_data()

def main():
    logger.info(f"Starting Enviro+ data sender - sending to {ENDPOINT_URL}")
    logger.info(f"Device UID: {DEVICE_UID}")
    logger.info("Setting up schedule for 6:00, 9:00, 12:00, 15:00, and 18:00 JST")
    
    # Schedule jobs at specific times (JST)
    schedule.every().day.at("06:00").do(process_and_send_data)
    schedule.every().day.at("09:00").do(process_and_send_data)
    schedule.every().day.at("12:00").do(process_and_send_data)
    schedule.every().day.at("15:00").do(process_and_send_data)
    schedule.every().day.at("18:00").do(process_and_send_data)
    
    logger.info("Running initial data collection and sending")
    process_and_send_data()  # Run once at startup
    
    try:
        while True:
            schedule.run_pending()
            time.sleep(30)  # Check every 30 seconds
            
    except KeyboardInterrupt:
        logger.info("Program stopped by user")
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        return 1
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
